To Have an idea regarding Assembly visit: https://www.tutorialspoint.com/assembly_programming/index.htm
This Text file will act as a guide and will teach you the fundamentals behind this project. This text file will be updated soon...
---------------------------------CPU AND INTERRUPTS----------------------------------

WHAT IS CPU FOR AN OPERATING SYSTEM DEVELOPER?
It is a shared extremely limited execution engine that must be controlled. A CPU can execute only one instruction at a time, but the OS needs to be a multi-tasking and must support various programs,
CPU IS OWNED BY THE KERNEL.
CPU does not understand complex instructions instead it performs specific tasks at one specific time.
That’s why when we write printf(“Hello world”); in C, CPU understands
LOAD REGISTER
JMP
PUSH
CALL
RETURN
FOR OS:
THE OPERATING SYSTEM MUST KNOW WHERE THE CPU IS EXECUTING, AT WHAT STATE THE CPU IS AND BE ABLE TO STOP AND RESUME EXECUTION SAFELY.
AT ANY MOMENT, THE CPU IS IN A STATE. CPU STATE INCLUDES
•	GENERAL REGISTERS (RAX, RBX, …)
•	INSTRUCTION POINTER ( RIP)
•	STACK POINTER (RSP)
•	FLAGS REGISTER ( ZF, CF, IF)
WHAT IS A CPU STATE?  A SNAPSHOT OF THE RUNNING PROGRAM.
NOW A QUESTION MAY ARISE WHY KERNEL MUST SAVE THE CPU STATE?
PROGRAM A IS RUNNING, KEYBOARD INTERRUPT OCCURS,
 

CPU MUST :
•	PAUSE PROGRAM A
•	SAVE ALL REGISTERS
•	JUMP TO KERNEL STATE
•	HANDLE KEYBOARD
•	RESTORE REGISTERS
•	RESUME PROGRAM A
WHAT HAPPENS IF EVEN ONE REGISTER IS NOT SAVED PROPERLY?  THE PROGRAM BEHAVES UNPREDICTABLY AND THE KERNEL CRASHES.
FROM THE KERNEL’S POINT OF VIEW
•	CPU IS NOT INFINITE
•	CPU TIME MUST BE DIVIDED
•	CPU TIME MUST BE SCHEDULED
THE OS MUST DECIDE:
•	WHO RUNS
•	FOR HOW LONG
•	WHEN TO STOP
CPU DOES NOT KNOW PROCESS, THREADS, PROGRAMS, USER; IT ONLY KNOWS CURRENT INSTRUCTION + REGISTERS.
SO KERNEL MUST 
•	MAP PROCESS  CPU STATE
•	SAVE / RESTORE STATES MANUALLY
 

---------------------------BOOTLOADER CONCEPT-----------------------

WHEN MACHINE POWERS ON:
THE CPU STARTS EXECUTING FROM A FIXED MEMORY ADDRESS WHEN NO OS EXISTS AND NO MEMORY PROTECTION, NO STACK.
THIS IS THE REASON FOR THE EXISTENCE OF THE BOOTLOADER,
UN THIS STATE, THE KERNEL MUST SET EVERYTHING MANUALLY.
WHY CPU MODES EXIST?
IF ANY CPU MODE WOULD NOT HAVE EXIST, ANY PROGRAM COULD 
•	ACCESS ANY MEMORY
•	READ/WRITE HARDWARE
•	STOP THE CPU
•	OVERWRITE THE OS CODE
THEN ONE BUGGY PROGRAM CRASHES THE WHOLE SYSTEM. 
WHAT IS CPU MODE?
CPU MODE DEFINES WHAT THE CURRENTLY RUNNING PROGRAM IS ALLOWED TO DO.
TWO MAIN MODES ARE:
(USER MODE / RESTRICTED) – IN MODERN OS
•	NORMAL PROGRAM RUNS HERE
•	BROWSER, EDITOR, GAMES
•	CANNOT ACCESS HARDWARE, ACCESS KERNEL MEMORY, AND EXECUTE PRIVILEGED INSTRUCTIONS.
(KERNEL MODE / PRIVILEGED)
•	OS KERNEL RUNS HERE
•	CAN – ACCESS ALL MEMORY, CONTROL HARDWARE AND HANDLE INTERRUPTS.
HARDWARE ENFORCED PROTECTIONS: THE KERNEL DOES NOT TRUST PROGRAMS, THE CPU PHYSICALLY BLOCK ILLEGAL ACTIONS.

HOW CPU  KNOWS THE CURRENT MODE:
CPU HAS A MODE BIT IN A SPECIAL REGISTER:
CONCEPT:
0 USER MODES
1 KERNEL MODES

ONLY 
1.	INTERRUPTS
2.	SYSTEM CALLS
3.	EXCEPTION
CAN SWITCH THESE MODES.
 HOW MODE SWITCH HAPPENS:
1.	SYSTEM CALLS
2.	HARDWARE INTERRUPTS
3.	CPU EXCEPTIONS
USER PROGRAM  SYSCALL  CPU SWITCHES MODE  KERNEL CODE RUNS
KERNEL  USER(SAFE EXIT)
1.	FINISHES WORK
2.	RESTORES CPU WORK
3.	EXPLICITLY RETURNS TO USER MODE

REASON FOR EXISTENCE OF SYSCALL:
1.	FILE READ
2.	MEMORY ALLOCATION
3.	NETWORK
4.	PRINT


------------INTERRUPTS-----------

CPU EXECUTES INSTRUCTIONS CONTINUOUSLY
OS WILL NEVER GET THE CONTROL BACK FROM A RUNNING PROGRAM IF CPU CONTINUOUSLY RUNS THE USER PROGRAM LEADS TO FAILURE OF MULTITASKING FEATURE NO KEYBOARD INPUT NO TIMER.

WHAT IS INTERRUPT?
AN INTERRUPT IS A HARDWARE CONTROLLED MECHANISM THAT FORCES THE CPU TO STOP ITS CURRENT EXECUTION AND JUMP TO THE KERNEL CODE.

WHAT HAPPENS DURING AN INTERRUPT?

USER PROGRAM RUNNING TIME INTERRUPT OCCURS  CPU FUNCTIONS (1. FINISHES CURRENT INSTRUCTION 2. SAVES CPU STATE (INSTRUCTION POINTER, FLAGS, REGISTERS), 3. SWITCHES TO KERNEL MODE, 4. SWITCHES TO KERNEL STACK, 5. JUMPS TO INTERRUPT HANDER ADDRESS.)


(in progress...)


